---
title: 动态规划
source: 
aliases: 
tags:
  - 数据结构
  - 动态规划
draft: false
date_created: 星期5 2024-09-13, 5:56:00 下午
date_modified: 星期5 2024-09-20, 10:32:43 晚上
---

```toc

```
# 动态规划

解题步骤：
1. 确定dp数组以及下标i的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 斐波那契数列

1. `dp[i]`的定义为：第i个斐波那契数列的值是`d[i]`
2. 确定递推公式`dp[i] = dp[i-1]+dp[i-2]`;
3. dp数组初始化:`dp[0] = 1;dp[1] = 2` 
4. 确定遍历顺序 从前往后
5. 举例推导dp数组


## 整数拆分
[343.整数拆分](https://leetcode.cn/problems/integer-break/solutions/352875/zheng-shu-chai-fen-by-leetcode-solution/)
### 分析
对于正整数$n$,当$n>=2$时,可以拆分成至少两个正整数的和,令$x$是拆分出的第一个正整数,则剩下的部分是$n-x$,$n-x$可以不继续拆分,或者继续拆分成至少两个正整数的和. 由于每个正整数对应的最大乘积取决于比它`小`的正整数对应的最大乘积,因此可以使用动态规划求解.

创建数组$dp$,其中$dp[i]$表示将正整数 $i$ 拆分成至少两个正整数之和之后,这些正整数的最大乘积.特别的,0不是正整数,1是最小的正整数,因此 $dp[0] = dp[1] = 0$ 
当 $i\geq 2$ 时,假设对正整数 $i$ 拆分出的第一个正整数是 $j(1\leq j \leq i)$ 则有以下两种方案:
- 将 $i$ 拆分成 $j$ 和 $i-j$ 且 $i-j$ 不再继续拆分成多个整数, 此时乘积是 $j * (i-j)$
- 将 $i$ 拆分成 $j$ 和 $i-j$ 的和 且 $i-j$ 继续拆分成多个正整数, 此时乘积是 $j * dp[i-j]$
因此,当 $j$ 固定时, 有 $dp[i] = \max(j*(i-j),j*dp[i-j])$. 由于 $j$ 的取值范围是1至i-1,需要遍历所有的 $j$ 得到 $dp[i]$ 的最大值,因此可以得到状态转移方程如下:

> [!note] 
> $dp[i] = \max(\max(j*(i-j),j*dp[i-j]))$

最终得到 $dp[n]$ 的值即为将正整数 $n$ 拆分成至少两个正整数的和之后,这些正整数的最大乘积.

```cpp
int integerBreak(int n) {
	vector<int> dp(n+1);
	dp[0] = dp[1] = 0;
	// dp[i] = i的最大拆分正整数乘积
	for(int i = 2;i<=n;i++){
		int curMax = 0;
		for(int j = 1;j<i;j++){
			curMax = max(curMax,max(j*(i-j),j*dp[i-j]));
		}
		dp[i] = curMax;
	}
	return dp[n];
}
```

## 01背包
问题描述：有 $n$ 件物品和一个最多能背重量为 $w$ 的背包。第i件物品的重量是 $weight[i]$，得到的价值是$value[i]$ 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

创建一个二维 $dp$ 数组,其中 $dp[i][j]$**表示从下标为 $[0-i]$ 的物品里任意取，放进容量为 $j$ 的背包，价值总和最大是多少**。
其中 $i.length = n \ \ j.length \in [0,w]$ 

两种情况，分别是放物品1 和 不放物品1，我们要取最大值（毕竟求的是最大价值）

$dp[1][4] = max(dp[0][4], dp[0][1] + 物品i 的价值)$

以上过程，抽象化如下：

- **不放物品i**：背包容量为$j$，里面不放物品i的最大价值是$dp[i - 1][j]$。
- **放物品i**：背包空出物品$i$的容量后，背包容量为$j - weight[i]$，$dp[i - 1][j - weight[i]]$ 为背包容量为$j - weight[i]$且不放物品i的最大价值，那么$dp[i - 1][j - weight[i]] + value[i]$ （物品i的价值），就是背包放物品i得到的最大价值
> [!note] 
递归公式： $dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);$

循环条件






