---
title: 动态规划
source: 
aliases: 
tags:
  - 数据结构
  - 动态规划
draft: false
date_created: 星期5 2024-09-13, 5:56:00 下午
date_modified: 星期2 2024-09-17, 4:16:43 下午
---

```toc

```
# 动态规划

解题步骤：
1. 确定dp数组以及下标i的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 斐波那契数列

1. `dp[i]`的定义为：第i个斐波那契数列的值是`d[i]`
2. 确定递推公式`dp[i] = dp[i-1]+dp[i-2]`;
3. dp数组初始化:`dp[0] = 1;dp[1] = 2` 
4. 确定遍历顺序 从前往后
5. 举例推导dp数组


## 整数拆分
[343.整数拆分](https://leetcode.cn/problems/integer-break/solutions/352875/zheng-shu-chai-fen-by-leetcode-solution/)
### 分析
对于正整数$n$,当$n>=2$时,可以拆分成至少两个正整数的和,令$x$是拆分出的第一个正整数,则剩下的部分是$n-x$,$n-x$可以不继续拆分,或者继续拆分成至少两个正整数的和. 由于每个正整数对应的最大乘积取决于比它`小`的正整数对应的最大乘积,因此可以使用动态规划求解.

创建数组$dp$,其中$dp[i]$表示将正整数 $i$ 拆分成至少两个正整数之和之后,这些正整数的最大乘积.特别的,0不是正整数,1是最小的正整数,因此 $dp[0] = dp[1] = 0$ 
当 $i\geq 2$ 时,假设对正整数 $i$ 拆分出的第一个正整数是 $j(1\leq j \leq i)$ 则有以下两种方案:
- 将 $i$ 拆分成 $j$ 和 $i-j$ 且 $i-j$ 不再继续拆分成多个整数, 此时乘积是 $j * (i-j)$
- 将 $i$ 拆分成 $j$ 和 $i-j$ 的和 且 $i-j$ 继续拆分成多个正整数, 此时乘积是 $j * dp[i-j]$
因此,当 $j$ 固定时, 有 $dp[i] = \max(j*(i-j),j*dp[i-j])$. 由于 $j$ 的取值范围是1至i-1,需要遍历所有的 $j$ 得到 $dp[i]$ 的最大值,因此可以得到状态转移方程如下:

> [!note] 
> $dp[i] = \max(\max(j*(i-j),j*dp[i-j]))$

最终得到 $dp[n]$ 的值即为将正整数 $n$ 拆分成至少两个正整数的和之后,这些正整数的最大乘积.

```cpp
int integerBreak(int n) {
	vector<int> dp(n+1);
	dp[0] = dp[1] = 0;
	// dp[i] = i的最大拆分正整数乘积
	for(int i = 2;i<=n;i++){
		int curMax = 0;
		for(int j = 1;j<i;j++){
			curMax = max(curMax,max(j*(i-j),j*dp[i-j]));
		}
		dp[i] = curMax;
	}
	return dp[n];
}
```
