---
title: 回溯
source: 
aliases: 
tags:
  - 算法
date_created: 星期3 2024-09-11, 7:42:18 晚上
date_modified: 星期2 2024-09-17, 4:16:43 下午
---

# 回溯
## 复原IP地址
**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和 `"192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

思路:由IP地址格式可知,当`.`的数量等于`3`时,地址来到最后一段,则我们可以判断当前位置`startIndex`到`s.size()-1`位置的字符串是否合法

**循环用来横向遍历,递归用于纵向遍历**

- 递归终止条件
	- 当`pointNum == 3`时,终止循环,若`startIndex~s.size()-1是合法IP地址,则加入结果集`
```cpp
if(pointNum==3){
	if(isValid(s,startIndex,s.size()-1)){
		result.push_back(s);
	}
}
```
- 递归循环条件 
	- 判断`isValid(s.startIndex,i)`是否合法,若合法则递归,若不合法则跳出.
	- 合法时在字符串中

**递归求解在当前长度下的所有可能,循环更新长度**


### 组合Ⅲ And 子集Ⅱ
**used[i - 1] == true，说明同一树枝candidates[i - 1]使用过**
**used[i - 1] == false，说明同一树层candidates[i - 1]使用过

去重需要排序
若不剪枝,则可能取重复